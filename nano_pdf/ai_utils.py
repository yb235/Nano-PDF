"""
AI utilities for Nano PDF - powered by Google Gemini.

This module provides:
- Slide editing with AI image generation
- Chart detection and data extraction
- Layout analysis and element detection
- Table extraction
- Text enhancement and OCR correction
"""

import os
import json
import re
from typing import List, Tuple, Optional, Dict, Any
from PIL import Image
from google import genai
from google.genai import types
from dotenv import load_dotenv

load_dotenv()


def get_client():
    """Get Gemini API client"""
    api_key = os.getenv("GEMINI_API_KEY")
    if not api_key:
        raise ValueError("GEMINI_API_KEY not found in environment variables")
    return genai.Client(api_key=api_key)


def _parse_json_from_response(text: str) -> Optional[Dict]:
    """Extract JSON from a response that may contain markdown code blocks"""
    if not text:
        return None
    
    # Try to find JSON in code blocks first
    json_patterns = [
        r'```json\s*([\s\S]*?)\s*```',
        r'```\s*([\s\S]*?)\s*```',
        r'\{[\s\S]*\}'
    ]
    
    for pattern in json_patterns:
        matches = re.findall(pattern, text)
        for match in matches:
            try:
                # Clean up the match
                json_str = match.strip()
                if json_str.startswith('{') or json_str.startswith('['):
                    return json.loads(json_str)
            except json.JSONDecodeError:
                continue
    
    # Try parsing the whole text as JSON
    try:
        return json.loads(text)
    except json.JSONDecodeError:
        return None


def _handle_api_error(e: Exception):
    """Handle Gemini API errors with helpful messages"""
    error_msg = str(e).lower()
    if "quota" in error_msg or "billing" in error_msg or "payment" in error_msg:
        raise RuntimeError(
            "Gemini API Error: This tool requires a PAID API key with billing enabled.\n"
            "Free tier keys do not support image generation. Please:\n"
            "1. Visit https://aistudio.google.com/api-keys\n"
            "2. Enable billing on your Google Cloud project\n"
            f"Original error: {e}"
        )
    elif "api key" in error_msg or "authentication" in error_msg or "unauthorized" in error_msg:
        raise RuntimeError(
            "Gemini API Error: Invalid API key.\n"
            "Please check that your GEMINI_API_KEY environment variable is set correctly.\n"
            f"Original error: {e}"
        )
    else:
        raise RuntimeError(f"Gemini API Error: {e}")


# ============================================================================
# Original Slide Editing Functions
# ============================================================================

def generate_edited_slide(
    target_image: Image.Image,
    style_reference_images: List[Image.Image],
    full_text_context: str,
    user_prompt: str,
    resolution: str = "4K",
    enable_search: bool = False
) -> Tuple[Image.Image, Optional[str]]:
    """
    Sends the target image, style refs, and text context to Gemini 3 Pro Image.
    Returns tuple of (generated PIL Image, optional text response).
    """
    client = get_client()

    # Construct the prompt
    prompt_parts = []

    prompt_parts.append(user_prompt)
    prompt_parts.append(target_image)

    if style_reference_images:
        prompt_parts.append("Match the visual style (fonts, colors, layout) of these reference images:")
        for img in style_reference_images:
            prompt_parts.append(img)

    if full_text_context:
        prompt_parts.append(f"DOCUMENT CONTEXT:\n{full_text_context}\n")

    # Build config - allow both text and image output
    config = types.GenerateContentConfig(
        response_modalities=['TEXT', 'IMAGE'],
        image_config=types.ImageConfig(
            image_size=resolution
        )
    )
    if enable_search:
        config.tools = [{"google_search": {}}]

    # Call the model
    try:
        response = client.models.generate_content(
            model='gemini-3-pro-image-preview',
            contents=prompt_parts,
            config=config
        )
    except Exception as e:
        _handle_api_error(e)

    # Extract image and text from the response
    generated_image = None
    response_text = None
    if response.candidates and response.candidates[0].content.parts:
        for part in response.candidates[0].content.parts:
            if part.inline_data:
                # Convert bytes to PIL Image
                from io import BytesIO
                generated_image = Image.open(BytesIO(part.inline_data.data))
            elif part.text:
                response_text = part.text

    if not generated_image:
        raise RuntimeError("No image generated by the model.")

    return generated_image, response_text


def generate_new_slide(
    style_reference_images: List[Image.Image],
    user_prompt: str,
    full_text_context: str = "",
    resolution: str = "4K",
    enable_search: bool = False
) -> Tuple[Image.Image, Optional[str]]:
    """
    Generates a completely new slide based on style references and a prompt.
    Returns tuple of (generated PIL Image, optional text response).
    """
    client = get_client()

    # Construct the prompt
    prompt_parts = []

    prompt_parts.append(user_prompt)

    if style_reference_images:
        prompt_parts.append("Match the visual style (fonts, colors, layout) of these reference images:")
        for img in style_reference_images:
            prompt_parts.append(img)

    if full_text_context:
        prompt_parts.append(f"DOCUMENT CONTEXT:\n{full_text_context}\n")

    # Build config - allow both text and image output
    config = types.GenerateContentConfig(
        response_modalities=['TEXT', 'IMAGE'],
        image_config=types.ImageConfig(
            image_size=resolution
        )
    )
    if enable_search:
        config.tools = [{"google_search": {}}]

    # Call the model
    try:
        response = client.models.generate_content(
            model='gemini-3-pro-image-preview',
            contents=prompt_parts,
            config=config
        )
    except Exception as e:
        _handle_api_error(e)

    # Extract image and text from the response
    generated_image = None
    response_text = None
    if response.candidates and response.candidates[0].content.parts:
        for part in response.candidates[0].content.parts:
            if part.inline_data:
                # Convert bytes to PIL Image
                from io import BytesIO
                generated_image = Image.open(BytesIO(part.inline_data.data))
            elif part.text:
                response_text = part.text

    if not generated_image:
        raise RuntimeError("No image generated by the model.")

    return generated_image, response_text


# ============================================================================
# PDF to PPT Conversion AI Functions
# ============================================================================

def analyze_page_for_charts(
    page_image: Image.Image,
    resolution: str = "4K"
) -> Optional[Dict[str, Any]]:
    """
    Analyze a PDF page image to detect and extract chart data.
    
    This function uses Gemini to:
    1. Detect if there are any charts/graphs on the page
    2. Identify the chart type(s)
    3. Extract the underlying data from each chart
    4. Determine bounding boxes for chart positions
    
    Args:
        page_image: PIL Image of the PDF page
        resolution: Image resolution for analysis
    
    Returns:
        Dictionary with chart analysis results containing detected charts
        with their types, data series, categories, and positions.
    """
    client = get_client()
    
    prompt = """Analyze this image from a PDF document. Your task is to detect and extract data from any charts, graphs, or data visualizations present.

For EACH chart/graph you find, extract:
1. Chart type (bar, column, line, pie, donut, area, scatter, bubble, stacked_bar, stacked_column, waterfall)
2. Chart title (if visible)
3. Categories/labels on the X-axis or pie slices
4. Data series with their names and values
5. Colors used for each series (as hex codes like #FF0000)
6. Axis titles
7. Approximate position as a fraction of the page (0-1 for x, y, width, height)
8. Whether data labels are shown
9. Whether a legend is visible

Return your analysis as JSON in this exact format:
```json
{
    "has_charts": true,
    "charts": [
        {
            "type": "column",
            "title": "Sales by Quarter",
            "categories": ["Q1", "Q2", "Q3", "Q4"],
            "series": [
                {
                    "name": "2023",
                    "values": [100, 150, 120, 180],
                    "color": "#4472C4"
                },
                {
                    "name": "2024",
                    "values": [120, 160, 140, 200],
                    "color": "#ED7D31"
                }
            ],
            "x_axis_title": "Quarter",
            "y_axis_title": "Sales ($M)",
            "bounding_box": {
                "x": 0.1,
                "y": 0.25,
                "width": 0.8,
                "height": 0.5
            },
            "data_labels": false,
            "show_legend": true,
            "colors": ["#4472C4", "#ED7D31"]
        }
    ]
}
```

If there are NO charts in the image, return:
```json
{
    "has_charts": false,
    "charts": []
}
```

IMPORTANT:
- Extract ACTUAL numerical values from the chart, not placeholders
- Read axis values carefully to determine the correct scale
- For pie charts, include percentage values if shown
- Estimate colors as closely as possible to hex codes
- Be precise with the bounding box coordinates

Analyze the image now:"""

    config = types.GenerateContentConfig(
        response_modalities=['TEXT'],
    )
    
    try:
        response = client.models.generate_content(
            model='gemini-2.5-flash-preview-05-20',
            contents=[prompt, page_image],
            config=config
        )
        
        if response.candidates and response.candidates[0].content.parts:
            for part in response.candidates[0].content.parts:
                if part.text:
                    result = _parse_json_from_response(part.text)
                    if result:
                        return result
        
        return {"has_charts": False, "charts": []}
        
    except Exception as e:
        print(f"Chart analysis failed: {e}")
        return {"has_charts": False, "charts": []}


def analyze_page_layout(
    page_image: Image.Image,
    resolution: str = "4K"
) -> Optional[Dict[str, Any]]:
    """
    Analyze the layout of a PDF page to identify all elements.
    
    Returns information about:
    - Text boxes (position, approximate content summary)
    - Images (position, description)
    - Charts (position, type)
    - Tables (position, structure)
    - Shapes (position, type, color)
    
    Args:
        page_image: PIL Image of the PDF page
        resolution: Image resolution for analysis
    
    Returns:
        Dictionary with layout analysis including element positions and types.
    """
    client = get_client()
    
    prompt = """Analyze the layout of this PDF page image. Identify and locate all visual elements.

For each element, provide:
1. Element type: "text", "image", "chart", "table", "shape", "logo"
2. Bounding box as fractions (0-1) of page dimensions: x, y, width, height
3. Brief description or content summary
4. For text: font size estimate (small/medium/large/title), bold/italic, color
5. For shapes: shape type, fill color, border color
6. For charts: chart type
7. For tables: rows x columns estimate

Return as JSON:
```json
{
    "elements": [
        {
            "type": "text",
            "bounding_box": {"x": 0.05, "y": 0.05, "width": 0.9, "height": 0.1},
            "content": "Main Title Here",
            "font_size": "title",
            "bold": true,
            "color": "#000000"
        },
        {
            "type": "chart",
            "bounding_box": {"x": 0.1, "y": 0.2, "width": 0.8, "height": 0.5},
            "chart_type": "bar",
            "description": "Sales comparison chart"
        },
        {
            "type": "image",
            "bounding_box": {"x": 0.7, "y": 0.05, "width": 0.25, "height": 0.1},
            "description": "Company logo"
        }
    ],
    "background_color": "#FFFFFF",
    "has_header": true,
    "has_footer": false
}
```

Analyze the page now:"""

    config = types.GenerateContentConfig(
        response_modalities=['TEXT'],
    )
    
    try:
        response = client.models.generate_content(
            model='gemini-2.5-flash-preview-05-20',
            contents=[prompt, page_image],
            config=config
        )
        
        if response.candidates and response.candidates[0].content.parts:
            for part in response.candidates[0].content.parts:
                if part.text:
                    result = _parse_json_from_response(part.text)
                    if result:
                        return result
        
        return None
        
    except Exception as e:
        print(f"Layout analysis failed: {e}")
        return None


def extract_table_data(
    page_image: Image.Image,
    table_region: Optional[Tuple[float, float, float, float]] = None,
    resolution: str = "4K"
) -> Optional[Dict[str, Any]]:
    """
    Extract table data from a PDF page image.
    
    Args:
        page_image: PIL Image of the PDF page
        table_region: Optional (x, y, width, height) as fractions to focus on
        resolution: Image resolution
    
    Returns:
        Dictionary with extracted table data including rows, columns,
        headers, and cell alignments.
    """
    client = get_client()
    
    region_text = ""
    if table_region:
        region_text = f"""
Focus on the table in this region of the image:
- X: {table_region[0]:.1%} from left
- Y: {table_region[1]:.1%} from top  
- Width: {table_region[2]:.1%}
- Height: {table_region[3]:.1%}
"""
    
    prompt = f"""Extract all data from the table(s) in this PDF page image.
{region_text}
For each table, provide:
1. All cell contents as a 2D array (rows and columns)
2. Whether the first row is a header
3. Column alignment (left/center/right) for each column
4. Bounding box position

Return as JSON:
```json
{{
    "tables": [
        {{
            "rows": [
                ["Product", "Q1", "Q2", "Q3", "Q4"],
                ["Widget A", "100", "150", "120", "180"],
                ["Widget B", "80", "90", "110", "130"]
            ],
            "has_header": true,
            "column_alignments": ["left", "right", "right", "right", "right"],
            "bounding_box": {{"x": 0.1, "y": 0.3, "width": 0.8, "height": 0.3}}
        }}
    ]
}}
```

If no tables are found, return:
```json
{{
    "tables": []
}}
```

Extract the table data now:"""

    config = types.GenerateContentConfig(
        response_modalities=['TEXT'],
    )
    
    try:
        response = client.models.generate_content(
            model='gemini-2.5-flash-preview-05-20',
            contents=[prompt, page_image],
            config=config
        )
        
        if response.candidates and response.candidates[0].content.parts:
            for part in response.candidates[0].content.parts:
                if part.text:
                    result = _parse_json_from_response(part.text)
                    if result:
                        return result
        
        return {"tables": []}
        
    except Exception as e:
        print(f"Table extraction failed: {e}")
        return {"tables": []}


def enhance_slide_extraction(
    page_image: Image.Image,
    extracted_text: str,
    resolution: str = "4K"
) -> Optional[Dict[str, Any]]:
    """
    Use AI to enhance and verify extracted slide content.
    
    This function takes raw extracted text and uses AI vision to:
    1. Verify and correct OCR errors
    2. Identify text hierarchy (titles, subtitles, body, bullets)
    3. Detect text styling (bold, italic, colors)
    4. Match text to visual positions
    
    Args:
        page_image: PIL Image of the PDF page
        extracted_text: Raw text extracted via OCR/PDF parsing
        resolution: Image resolution
    
    Returns:
        Enhanced extraction with corrected text and styling information.
    """
    client = get_client()
    
    prompt = f"""I have extracted the following text from a PDF page:

<extracted_text>
{extracted_text[:3000]}  
</extracted_text>

Compare this with the actual image and provide:
1. Corrected text (fix any OCR errors)
2. Text hierarchy (title, subtitle, heading, body, bullet, caption, footer)
3. Approximate styling (bold, italic, size category, color)
4. Spatial grouping (which text belongs together)

Return as JSON:
```json
{{
    "text_blocks": [
        {{
            "text": "Corrected Main Title",
            "hierarchy": "title",
            "bold": true,
            "italic": false,
            "size_category": "large",
            "color": "#000000",
            "group_id": 1
        }},
        {{
            "text": "Bullet point 1",
            "hierarchy": "bullet",
            "bold": false,
            "italic": false,
            "size_category": "medium",
            "color": "#333333",
            "group_id": 2,
            "bullet_level": 1
        }}
    ],
    "corrections_made": ["Fixed 'teh' to 'the'", "Corrected number formatting"]
}}
```

Analyze and enhance the extraction:"""

    config = types.GenerateContentConfig(
        response_modalities=['TEXT'],
    )
    
    try:
        response = client.models.generate_content(
            model='gemini-2.5-flash-preview-05-20',
            contents=[prompt, page_image],
            config=config
        )
        
        if response.candidates and response.candidates[0].content.parts:
            for part in response.candidates[0].content.parts:
                if part.text:
                    result = _parse_json_from_response(part.text)
                    if result:
                        return result
        
        return None
        
    except Exception as e:
        print(f"Enhancement failed: {e}")
        return None


def generate_ppt_from_pdf_page(
    page_image: Image.Image,
    style_reference_images: Optional[List[Image.Image]] = None,
    resolution: str = "4K"
) -> Tuple[Optional[Image.Image], Optional[str]]:
    """
    Generate an enhanced PowerPoint-ready image from a PDF page.
    
    This can be used as a fallback when element extraction fails,
    or to enhance the visual quality of the converted slide.
    
    Args:
        page_image: PIL Image of the PDF page
        style_reference_images: Optional reference images for style matching
        resolution: Output resolution
    
    Returns:
        Tuple of (enhanced image, response text)
    """
    client = get_client()
    
    prompt_parts = [
        """Recreate this slide as a high-quality, clean presentation slide image.
        
Maintain:
- Exact same content and text
- Same layout and positioning
- Same colors and styling
- Same charts/graphs (if present)
- Same images and shapes

Improve:
- Crisp, clean rendering suitable for presentations
- Professional PowerPoint aesthetic
- Clear, readable text
- Sharp graphics

Generate the enhanced slide image:""",
        page_image
    ]
    
    if style_reference_images:
        prompt_parts.append("Use the visual style from these references:")
        prompt_parts.extend(style_reference_images)
    
    config = types.GenerateContentConfig(
        response_modalities=['TEXT', 'IMAGE'],
        image_config=types.ImageConfig(
            image_size=resolution
        )
    )
    
    try:
        response = client.models.generate_content(
            model='gemini-3-pro-image-preview',
            contents=prompt_parts,
            config=config
        )
        
        generated_image = None
        response_text = None
        
        if response.candidates and response.candidates[0].content.parts:
            for part in response.candidates[0].content.parts:
                if part.inline_data:
                    from io import BytesIO
                    generated_image = Image.open(BytesIO(part.inline_data.data))
                elif part.text:
                    response_text = part.text
        
        return generated_image, response_text
        
    except Exception as e:
        print(f"Image generation failed: {e}")
        return None, None


def extract_slide_content_comprehensive(
    page_image: Image.Image,
    resolution: str = "4K"
) -> Optional[Dict[str, Any]]:
    """
    Comprehensive extraction of all slide content for PDF to PPT conversion.
    
    This is the main function for extracting slide content. It analyzes
    the entire slide and returns structured data for all elements including:
    - Text with exact content, position, and styling
    - Charts with data that can be recreated as editable charts
    - Tables with full cell content
    - Images with descriptions
    - Shapes with colors and positions
    
    Args:
        page_image: PIL Image of the PDF page
        resolution: Image resolution
    
    Returns:
        Comprehensive slide content dictionary for PPT generation.
    """
    client = get_client()
    
    prompt = """Perform a comprehensive analysis of this presentation slide image to extract ALL content for recreation in PowerPoint.

Extract the following with MAXIMUM PRECISION:

## 1. TEXT CONTENT
For each text element:
- Exact text content (preserve line breaks)
- Position (x, y, width, height as fractions 0-1)
- Font properties: name/family, size (in points estimate), bold, italic, underline
- Color (hex code)
- Alignment (left/center/right/justify)
- Is it a title, subtitle, body, bullet, header, footer?
- Bullet level (if applicable)

## 2. CHARTS (Critical - need exact data for editable charts!)
For each chart:
- Chart type: bar, column, line, pie, donut, area, scatter, stacked_bar, stacked_column
- Title
- ALL categories/labels exactly as shown
- ALL data series with:
  - Series name
  - Exact numerical values (READ CAREFULLY from axes/labels)
  - Color (hex)
- Axis titles
- Legend visibility and position
- Position (x, y, width, height)

## 3. TABLES
For each table:
- Complete 2D array of cell contents
- Header row identification
- Cell background colors
- Cell text alignment

## 4. IMAGES/GRAPHICS
For each image:
- Position and size
- Description of content
- Whether it's a logo, photo, diagram, icon

## 5. SHAPES
For each shape:
- Type (rectangle, oval, arrow, etc.)
- Position and size
- Fill color
- Border color
- Any text inside

## 6. SLIDE PROPERTIES
- Background color or gradient
- Overall color theme

Return as structured JSON:
```json
{
    "slide_properties": {
        "background_color": "#FFFFFF",
        "theme_colors": ["#4472C4", "#ED7D31", "#A5A5A5"]
    },
    "text_elements": [
        {
            "text": "Exact slide title text",
            "position": {"x": 0.05, "y": 0.05, "width": 0.9, "height": 0.12},
            "font": {
                "name": "Calibri",
                "size": 44,
                "bold": true,
                "italic": false,
                "underline": false,
                "color": "#000000"
            },
            "alignment": "center",
            "type": "title"
        }
    ],
    "charts": [
        {
            "type": "column",
            "title": "Chart Title",
            "position": {"x": 0.1, "y": 0.25, "width": 0.8, "height": 0.5},
            "categories": ["Jan", "Feb", "Mar", "Apr"],
            "series": [
                {"name": "Series 1", "values": [10, 20, 30, 40], "color": "#4472C4"},
                {"name": "Series 2", "values": [15, 25, 35, 45], "color": "#ED7D31"}
            ],
            "x_axis_title": "Month",
            "y_axis_title": "Value",
            "legend": {"visible": true, "position": "bottom"},
            "data_labels": false
        }
    ],
    "tables": [
        {
            "position": {"x": 0.1, "y": 0.3, "width": 0.8, "height": 0.4},
            "rows": [
                [{"text": "Header 1", "bold": true, "bg_color": "#4472C4", "font_color": "#FFFFFF"}, 
                 {"text": "Header 2", "bold": true, "bg_color": "#4472C4", "font_color": "#FFFFFF"}],
                [{"text": "Cell 1", "bold": false}, {"text": "Cell 2", "bold": false}]
            ],
            "column_widths": [0.5, 0.5]
        }
    ],
    "images": [
        {
            "position": {"x": 0.8, "y": 0.02, "width": 0.15, "height": 0.1},
            "description": "Company logo - blue circular emblem",
            "type": "logo"
        }
    ],
    "shapes": [
        {
            "type": "rectangle",
            "position": {"x": 0.05, "y": 0.95, "width": 0.9, "height": 0.03},
            "fill_color": "#4472C4",
            "border_color": null,
            "text": null
        }
    ]
}
```

CRITICAL INSTRUCTIONS:
1. For charts, READ THE ACTUAL VALUES from the chart - use axis scales and data labels
2. Preserve exact text content including any numbers, percentages, dates
3. Colors should be close hex approximations
4. Positions are fractions of slide dimensions (0-1)
5. Include ALL elements, even small ones

Analyze this slide now:"""

    config = types.GenerateContentConfig(
        response_modalities=['TEXT'],
    )
    
    try:
        response = client.models.generate_content(
            model='gemini-2.5-flash-preview-05-20',
            contents=[prompt, page_image],
            config=config
        )
        
        if response.candidates and response.candidates[0].content.parts:
            for part in response.candidates[0].content.parts:
                if part.text:
                    result = _parse_json_from_response(part.text)
                    if result:
                        return result
        
        return None
        
    except Exception as e:
        print(f"Comprehensive extraction failed: {e}")
        return None
